@page "/home"
@inject GameState GameState;
@using Microsoft.AspNetCore.SignalR.Client
@using BattleShip.Models.Responses
@implements IAsyncDisposable


<div class="container text-center">
    <h1 class="m-3"> The War of the Sea</h1>
    <div class="row justify-content-center">
        <div class="col">
            <h1>My Ships</h1>
            <BoardUser Table="UserBoard"/>
            <History HistoryItems="_userHistory"></History>
        </div>
        <div class="col">
            <h1>Opponent's Ships</h1>
            <BoardOpponent Table="OpponentBoard" OnUpdate="a => UpdateOpponentBoard(a.UserResult, a.col, a.row)"/>
            <History HistoryItems="_opponentHistory"></History>
        </div>
    </div>

</div>

@code{
    [Parameter] public char[,] UserBoard { get; set; } = GameState.Instance.UserBoard;
    [Parameter] public char[,] OpponentBoard { get; set; } = GameState.Instance.OpponentBoard;
    private readonly List<string> _userHistory = new();
    private readonly List<string> _opponentHistory = new();


    private HubConnection? _hubConnection;
    private readonly List<string> _messages = new();
    private string? _userInput;
    private string? _messageInput;

    protected override async Task OnInitializedAsync()
    {
        //TODO : use app.settings et IConfiguration
        _hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost:5000/playerhub")
            .Build();


        _hubConnection.On<AttackResponse>("ReceiveAttackResult", attackResponse =>
        {
            var statusMessage = $"Game Status: {attackResponse.GameStatus}";

            // If there's a ship name, include it in the message
            var shipMessage = attackResponse.ShipName != null ? $" on {attackResponse.ShipName}" : "";

            // Indicate if the ship was sunk
            var sunkMessage = attackResponse.Sunk ? " and sunk it!" : "";

            // Combine all parts to create the final message
            var encodedMsg = $"AI Attack Result: {shipMessage}{sunkMessage}. {statusMessage}";

            // Add the message to the list
            _messages.Add(encodedMsg);

            UpdateUserBoard(attackResponse);
            // Refresh the UI
            InvokeAsync(StateHasChanged);
        });

        // Démarrage de la connexion au hub
        await _hubConnection.StartAsync();


        // Appel de la méthode "RegisterUserId" sur le hub après l'établissement de la connexion
        await _hubConnection.InvokeAsync("RegisterUserId", GameState.PlayerId);
    }


    private async Task Send()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.SendAsync("SendMessage", _userInput, _messageInput);
        }
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private void UpdateUserBoard(AttackResponse opponentAttack)
    {
        var value = 'O';
        switch (opponentAttack.Result)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {opponentAttack.Coordinates.X},{opponentAttack.Coordinates.Y}");
                return;
        }

        UserBoard[opponentAttack.Coordinates.X, opponentAttack.Coordinates.Y] = value;
        _userHistory.Add($"Play: {opponentAttack.Coordinates.X},{opponentAttack.Coordinates.Y} - Result: {opponentAttack.Result}");
        StateHasChanged();
    }

    private void UpdateOpponentBoard(AttackResponse playerAttack, int col, int row)
    {
        var value = 'O';
        switch (playerAttack.Result)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {col},{row}");
                return;
        }

        OpponentBoard[col, row] = value;
        _opponentHistory.Add($"Play: {col},{row} - Result: {playerAttack.Result}");
        StateHasChanged();
    }

}