@page "/home"
@using Microsoft.AspNetCore.SignalR.Client
@using BattleShip.Models
@inject GameState GameState;
@using BattleShip.Models.Responses
@implements IAsyncDisposable


@if (ShowWaitingPopup && GameState.Mode == GameMode.Multiplayer)
{
    Console.WriteLine($"State popup : {ShowWaitingPopup}  {GameState.IsHost}");
    <div class="overlay"></div>
    <div class="waiting-popup">
        Waiting from connection...
    </div>
}

@if (ShowWaitingPlayerPopup && GameState.Mode == GameMode.Multiplayer)
{
    Console.WriteLine($"State popup : {ShowWaitingPlayerPopup}  {GameState.IsHost}");
    <div class="overlay"></div>
    <div class="waiting-popup">
        Waiting for opponent plays...
    </div>
}
<div class="container text-center">
    <h1 class="m-3"> The War of the Sea</h1>
    <div class="row justify-content-center">
        <div class="col">
            <h1>My Ships</h1>
            <BoardUser Table="UserBoard"/>
            <History HistoryItems="_userHistory"></History>
        </div>
        <div class="col">
            <h1>Opponent's Ships</h1>
            <BoardOpponent Table="OpponentBoard" OnUpdate="a => UpdateOpponentBoard(a.UserResult, a.col, a.row)"/>
            <History HistoryItems="_opponentHistory"></History>
        </div>
    </div>

</div>
<style>
    .waiting-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
     .overlay {
         
             position: fixed;
             top: 0;
             left: 0;
             width: 100vw;
             height: 100vh;
             background-color: rgba(0,0,0,0.5);
             z-index: 99;
         }
</style>
@code{
    [Parameter] public char[,] UserBoard { get; set; } = GameState.Instance.UserBoard;
    [Parameter] public char[,] OpponentBoard { get; set; } = GameState.Instance.OpponentBoard;
    [Parameter] public bool IsHost { get; set; } = GameState.Instance.IsHost;
    private readonly List<string> _userHistory = new();
    private readonly List<string> _opponentHistory = new();


    private HubConnection? _hubConnection;
    private readonly List<string> _messages = new();
    private string? _userInput;
    private string? _messageInput;
    public bool ShowWaitingPopup;
    public bool ShowWaitingPlayerPopup;
    
    protected override async Task OnInitializedAsync()
    {
        if(GameState.IsHost)
        {
            ShowWaitingPopup = true;
            ShowWaitingPlayerPopup = false;
        }
        else
        {
            ShowWaitingPopup = false;
            ShowWaitingPlayerPopup = true;
        }
        //TODO : use app.settings et IConfiguration
        _hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost:5000/playerhub")
            .Build();


        _hubConnection.On<AttackResponse>("ReceiveAttackResult", attackResponse =>
        {
            var statusMessage = $"Game Status: {attackResponse.GameStatus}";

            // If there's a ship name, include it in the message
            var shipMessage = attackResponse.ShipName != null ? $" on {attackResponse.ShipName}" : "";

            // Indicate if the ship was sunk
            var sunkMessage = attackResponse.Sunk ? " and sunk it!" : "";

            // Combine all parts to create the final message
            var encodedMsg = $"AI Attack Result: {shipMessage}{sunkMessage}. {statusMessage}";

            // Add the message to the list
            _messages.Add(encodedMsg);

            UpdateUserBoard(attackResponse);
            ShowWaitingPlayerPopup = false;
            // Refresh the UI
            StateHasChanged();
        });
        
        _hubConnection.On<TryJoinGameResponse>("GameJoined", (joinResponse) =>
        {
            Console.WriteLine($"Game Joined {joinResponse.Status}");
            if (joinResponse.Status == GameStatus.InProgress)
            {
                ShowWaitingPopup = false;
                ShowWaitingPlayerPopup = false;
                _messages.Add("Game Joined");
            }
            
            StateHasChanged();
        });

        // Démarrage de la connexion au hub
        await _hubConnection.StartAsync();


        // Appel de la méthode "RegisterUserId" sur le hub après l'établissement de la connexion
        await _hubConnection.InvokeAsync("RegisterUserId", GameState.PlayerId);
    }


    private async Task Send()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.SendAsync("SendMessage", _userInput, _messageInput);
        }
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private void UpdateUserBoard(AttackResponse opponentAttack)
    {
        var value = 'O';
        switch (opponentAttack.Result)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {opponentAttack.Coordinates.X},{opponentAttack.Coordinates.Y}");
                return;
        }

        UserBoard[opponentAttack.Coordinates.X, opponentAttack.Coordinates.Y] = value;
        _userHistory.Add($"Play: {opponentAttack.Coordinates.X},{opponentAttack.Coordinates.Y} - Result: {opponentAttack.Result}");
        StateHasChanged();
    }

    private void UpdateOpponentBoard(AttackResponse playerAttack, int col, int row)
    {
        var value = 'O';
        switch (playerAttack.Result)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {col},{row}");
                return;
        }

        OpponentBoard[col, row] = value;
        _opponentHistory.Add($"Play: {col},{row} - Result: {playerAttack.Result}");
        StateHasChanged();
    }

}