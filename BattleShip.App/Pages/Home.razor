@page "/home"
@inject NavigationManager Navigation
@inject GameState GameState;
@using Microsoft.AspNetCore.SignalR.Client
@using BattleShip.Models.Response
@implements IAsyncDisposable

<h3>Home</h3>

<div class="boards-container">
    <div>
        <h5>Player 1 Board</h5>
        <BoardUser Table="UserBoard"/>
        <History></History>
    </div>

    <div>
        <h5>Player 2 Board</h5>
        <BoardOpponent Table="OpponentBoard" OnUpdate="a => UpdateOpponentBoard(a.UserResult, a.col, a.row)"/>
        <History></History>
    </div>
</div>

<style>
    .boards-container {
        display: flex;
        justify-content: space-around;
    }

    .boards-container > div {
        margin: 10px;
    }
</style>

@code{
    [Parameter] public char[,] UserBoard { get; set; } = GameState.Instance.UserBoard;
    [Parameter] public char[,] OpponentBoard { get; set; } = GameState.Instance.OpponentBoard;

    private HubConnection? hubConnection;
    private readonly List<string> messages = new();
    private string? userInput;
    private string? messageInput;

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/playerHub"))
            .Build();


        hubConnection.On<AttackResponse>("ReceiveAttackResult", attackResponse =>
        {
            Console.Write("WESH");
            var statusMessage = $"Game Status: {attackResponse.GameStatus}";

            // If there's a ship name, include it in the message
            var shipMessage = attackResponse.ShipName != null ? $" on {attackResponse.ShipName}" : "";

            // Indicate if the ship was sunk
            var sunkMessage = attackResponse.Sunk ? " and sunk it!" : "";

            // Combine all parts to create the final message
            var encodedMsg = $"AI Attack Result: {shipMessage}{sunkMessage}. {statusMessage}";

            // Add the message to the list
            messages.Add(encodedMsg);

            // Refresh the UI
            InvokeAsync(StateHasChanged);
        });

        // Démarrage de la connexion au hub
        await hubConnection.StartAsync();


        // Appel de la méthode "RegisterUserId" sur le hub après l'établissement de la connexion
        await hubConnection.InvokeAsync("RegisterUserId", GameState.PlayerId);
    }


    private async Task Send()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("SendMessage", userInput, messageInput);
        }
    }

    public bool IsConnected =>
        hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    /*private void UpdateUserBoard(AttackResponse AiAttack)
    {
        var value = 'O';
        switch (AiAttack.Outcome)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {AiAttack.Coordinates[0]},{AiAttack.Coordinates[1]}");
                return;
        }
        UserBoard[AiAttack.Coordinates[0], AiAttack.Coordinates[1]] = value;
        StateHasChanged();
    }*/

    private void UpdateOpponentBoard(AttackResponse playerAttack, int col, int row)
    {
        var value = 'O';
        switch (playerAttack.Result)
        {
            case AttackOutcome.Hit:
                value = 'X';
                break;
            case AttackOutcome.Sunk:
                Console.Write("Sunk");
                break;
            case AttackOutcome.AlreadyAttacked:
                Console.WriteLine($"Error: Player Already Attacked {col},{row}");
                return;
        }

        OpponentBoard[col, row] = value;
        StateHasChanged();
        //UpdateUserBoard(AiAttack);
    }

}